import { generateObject } from 'ai';
import { z } from 'zod';

import { getModel } from '../ai/providers';
import { EthersProvider } from '../blockchain/provider';
import { BugBountyPlatformScraper, BountyProgram } from '../platforms/bounty-scraper';
import { GitHubScanner, GitHubRepo, SmartContractFile } from '../platforms/github-scanner';
import { StaticAnalysisEngine, AnalysisResult } from './static-analysis';

export interface VulnerabilityTarget {
  type: 'repository' | 'contract' | 'protocol';
  identifier: string; // repo URL or contract address
  source: string; // where we found this target
  priority: 'high' | 'medium' | 'low';
  reasoning: string;
  bountyProgram?: BountyProgram;
  analysisResult?: AnalysisResult;
}

export interface VulnerabilityResearchResult {
  targets: VulnerabilityTarget[];
  summary: string;
  recommendations: string[];
  potentialFindings: string[];
  riskAssessment: {
    highRiskTargets: number;
    mediumRiskTargets: number;
    lowRiskTargets: number;
    totalTargets: number;
  };
}

export class VulnerabilityResearchEngine {
  private ethersProvider: EthersProvider;
  private githubScanner: GitHubScanner;
  private bountyScanner: BugBountyPlatformScraper;
  private staticAnalyzer: StaticAnalysisEngine;

  constructor(options: {
    githubToken?: string;
    ethersRpcUrl?: string;
  } = {}) {
    this.ethersProvider = EthersProvider.getInstance(options.ethersRpcUrl);
    this.githubScanner = new GitHubScanner(options.githubToken);
    this.bountyScanner = new BugBountyPlatformScraper();
    this.staticAnalyzer = new StaticAnalysisEngine();
  }

  async conductVulnerabilityResearch(query: string, options: {
    maxTargets?: number;
    focusOnBounties?: boolean;
    includeContractAnalysis?: boolean;
    minStars?: number;
  } = {}): Promise<VulnerabilityResearchResult> {
    const {
      maxTargets = 20,
      focusOnBounties = true,
      includeContractAnalysis = true,
      minStars = 50
    } = options;

    console.log('üîç Starting vulnerability research...');
    
    const targets: VulnerabilityTarget[] = [];

    // Step 1: Find bug bounty programs
    if (focusOnBounties) {
      console.log('üìã Scanning bug bounty platforms...');
      const bountyPrograms = await this.findRelevantBountyPrograms(query);
      
      for (const program of bountyPrograms.slice(0, Math.floor(maxTargets / 2))) {
        const target = await this.createTargetFromBountyProgram(program);
        if (target) targets.push(target);
      }
    }

    // Step 2: Find GitHub repositories with smart contracts
    console.log('üìÇ Scanning GitHub repositories...');
    const repos = await this.findVulnerableRepositories(query, {
      maxResults: maxTargets,
      minStars,
      hasBounty: focusOnBounties
    });

    for (const repo of repos.slice(0, maxTargets - targets.length)) {
      const target = await this.createTargetFromRepository(repo, includeContractAnalysis);
      if (target) targets.push(target);
    }

    // Step 3: Analyze findings and generate insights
    console.log('üß† Generating vulnerability insights...');
    const insights = await this.generateVulnerabilityInsights(targets, query);

    // Step 4: Calculate risk assessment
    const riskAssessment = this.calculateRiskAssessment(targets);

    return {
      targets,
      summary: insights.summary,
      recommendations: insights.recommendations,
      potentialFindings: insights.potentialFindings,
      riskAssessment
    };
  }

  private async findRelevantBountyPrograms(query: string): Promise<BountyProgram[]> {
    const allPrograms = await this.bountyScanner.getAllBountyPrograms();
    
    // Filter programs based on query relevance
    const relevantPrograms = allPrograms.filter(program => {
      const searchText = `${program.name} ${program.description} ${program.technology.join(' ')}`.toLowerCase();
      const queryTerms = query.toLowerCase().split(' ');
      return queryTerms.some(term => searchText.includes(term));
    });

    return relevantPrograms.sort((a, b) => {
      // Prioritize by platform and reward
      const platformPriority = { 'ImmuneFi': 4, 'Code4rena': 3, 'HackerOne': 2, 'Bugcrowd': 1 };
      return (platformPriority[b.platform as keyof typeof platformPriority] || 0) - 
             (platformPriority[a.platform as keyof typeof platformPriority] || 0);
    });
  }

  private async findVulnerableRepositories(query: string, options: {
    maxResults: number;
    minStars: number;
    hasBounty: boolean;
  }): Promise<GitHubRepo[]> {
    // Search for repositories with vulnerability-related terms
    const searchQueries = [
      `${query} solidity smart contract`,
      `${query} defi protocol vulnerability`,
      `${query} blockchain security audit`,
      `smart contract ${query}`,
      `defi ${query} security`
    ];

    const allRepos: GitHubRepo[] = [];

    for (const searchQuery of searchQueries) {
      if (allRepos.length >= options.maxResults) break;

      const repos = await this.githubScanner.findSmartContractRepos(searchQuery, {
        maxResults: Math.ceil(options.maxResults / searchQueries.length),
        minStars: options.minStars,
        hasBounty: options.hasBounty
      });

      allRepos.push(...repos);
    }

    // Remove duplicates and sort by relevance
    const uniqueRepos = Array.from(
      new Map(allRepos.map(repo => [repo.fullName, repo])).values()
    );

    return uniqueRepos
      .sort((a, b) => b.stars - a.stars)
      .slice(0, options.maxResults);
  }

  private async createTargetFromBountyProgram(program: BountyProgram): Promise<VulnerabilityTarget | null> {
    try {
      const priority = this.assessBountyProgramPriority(program);
      const reasoning = this.generateBountyProgramReasoning(program);

      return {
        type: 'protocol',
        identifier: program.url,
        source: `${program.platform} bounty program`,
        priority,
        reasoning,
        bountyProgram: program
      };
    } catch (error) {
      console.error(`Error creating target from bounty program ${program.name}:`, error);
      return null;
    }
  }

  private async createTargetFromRepository(repo: GitHubRepo, includeAnalysis: boolean): Promise<VulnerabilityTarget | null> {
    try {
      let analysisResult: AnalysisResult | undefined;

      if (includeAnalysis) {
        // Get smart contract files and analyze them
        const contractFiles = await this.githubScanner.getSmartContractFiles(repo, 5);
        
        if (contractFiles.length > 0) {
          // Analyze the most significant contract file
          const mainContract = contractFiles.sort((a, b) => b.size - a.size)[0];
          if (mainContract) {
            analysisResult = await this.staticAnalyzer.analyzeSourceCode(
              mainContract.content,
              `${repo.fullName}/${mainContract.path}`
            );
          }
        }
      }

      const priority = this.assessRepositoryPriority(repo, analysisResult);
      const reasoning = this.generateRepositoryReasoning(repo, analysisResult);

      return {
        type: 'repository',
        identifier: repo.url,
        source: 'GitHub search',
        priority,
        reasoning,
        analysisResult
      };
    } catch (error) {
      console.error(`Error creating target from repository ${repo.fullName}:`, error);
      return null;
    }
  }

  private assessBountyProgramPriority(program: BountyProgram): 'high' | 'medium' | 'low' {
    const rewardValue = this.extractRewardValue(program.rewardRange);
    const platformScore = { 'ImmuneFi': 3, 'Code4rena': 3, 'HackerOne': 2, 'Bugcrowd': 2 }[program.platform] || 1;

    if (rewardValue >= 100000 || platformScore >= 3) return 'high';
    if (rewardValue >= 25000 || platformScore >= 2) return 'medium';
    return 'low';
  }

  private assessRepositoryPriority(repo: GitHubRepo, analysis?: AnalysisResult): 'high' | 'medium' | 'low' {
    let score = 0;

    // Stars-based scoring
    if (repo.stars >= 1000) score += 3;
    else if (repo.stars >= 100) score += 2;
    else if (repo.stars >= 10) score += 1;

    // Bounty indicators
    if (repo.bountyIndicators.length > 0) score += 3;

    // Analysis results
    if (analysis && analysis.riskScore >= 70) score += 3;
    else if (analysis && analysis.riskScore >= 40) score += 2;
    else if (analysis && analysis.riskScore > 0) score += 1;

    // DeFi/Finance related projects are higher priority
    const highValueKeywords = ['defi', 'finance', 'lending', 'vault', 'treasury', 'dao'];
    if (highValueKeywords.some(keyword => 
      repo.description.toLowerCase().includes(keyword) || 
      repo.topics.some(topic => topic.toLowerCase().includes(keyword))
    )) {
      score += 2;
    }

    if (score >= 6) return 'high';
    if (score >= 3) return 'medium';
    return 'low';
  }

  private generateBountyProgramReasoning(program: BountyProgram): string {
    const rewardValue = this.extractRewardValue(program.rewardRange);
    return `Bug bounty program on ${program.platform} with rewards up to ${program.rewardRange}. ` +
           `Technologies: ${program.technology.join(', ')}. ` +
           `High-value target due to established bounty program and significant reward potential.`;
  }

  private generateRepositoryReasoning(repo: GitHubRepo, analysis?: AnalysisResult): string {
    let reasoning = `GitHub repository with ${repo.stars} stars. `;
    
    if (repo.bountyIndicators.length > 0) {
      reasoning += `Has bug bounty indicators: ${repo.bountyIndicators.join(', ')}. `;
    }

    if (analysis) {
      reasoning += `Static analysis reveals ${analysis.vulnerabilities.length} potential vulnerabilities ` +
                  `with risk score ${analysis.riskScore}/100. `;
    }

    reasoning += `Language: ${repo.language}. Topics: ${repo.topics.join(', ')}.`;

    return reasoning;
  }

  private extractRewardValue(rewardRange: string): number {
    const matches = rewardRange.match(/\$?([\d,]+)/);
    if (matches && matches[1]) {
      return parseInt(matches[1].replace(/,/g, ''));
    }
    return 0;
  }

  private async generateVulnerabilityInsights(targets: VulnerabilityTarget[], originalQuery: string): Promise<{
    summary: string;
    recommendations: string[];
    potentialFindings: string[];
  }> {
    const targetsData = targets.map(target => ({
      type: target.type,
      priority: target.priority,
      reasoning: target.reasoning,
      vulnerabilities: target.analysisResult?.vulnerabilities.length || 0,
      riskScore: target.analysisResult?.riskScore || 0
    }));

    const prompt = `Based on the vulnerability research for "${originalQuery}", analyze these targets and provide insights:

Targets found: ${JSON.stringify(targetsData, null, 2)}

Please provide:
1. A comprehensive summary of the research findings
2. Specific recommendations for where to focus security research efforts
3. Potential vulnerability types to look for based on the targets`;

    try {
      const result = await generateObject({
        model: getModel(),
        schema: z.object({
          summary: z.string().describe('Comprehensive summary of vulnerability research findings'),
          recommendations: z.array(z.string()).describe('Specific actionable recommendations'),
          potentialFindings: z.array(z.string()).describe('Types of vulnerabilities likely to be found')
        }),
        prompt
      });

      return result.object;
    } catch (error) {
      console.error('Error generating insights:', error);
      return {
        summary: `Found ${targets.length} potential targets for vulnerability research related to "${originalQuery}".`,
        recommendations: ['Manual code review of high-priority targets', 'Focus on smart contract vulnerabilities'],
        potentialFindings: ['Access control issues', 'Reentrancy vulnerabilities', 'Integer overflow/underflow']
      };
    }
  }

  private calculateRiskAssessment(targets: VulnerabilityTarget[]): {
    highRiskTargets: number;
    mediumRiskTargets: number;
    lowRiskTargets: number;
    totalTargets: number;
  } {
    const assessment = {
      highRiskTargets: 0,
      mediumRiskTargets: 0,
      lowRiskTargets: 0,
      totalTargets: targets.length
    };

    for (const target of targets) {
      switch (target.priority) {
        case 'high':
          assessment.highRiskTargets++;
          break;
        case 'medium':
          assessment.mediumRiskTargets++;
          break;
        case 'low':
          assessment.lowRiskTargets++;
          break;
      }
    }

    return assessment;
  }
}