export interface VulnerabilityPattern {
  name: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  pattern: RegExp | string;
  category: 'access_control' | 'reentrancy' | 'arithmetic' | 'logic' | 'gas' | 'random' | 'dos' | 'privacy';
}

export interface AnalysisResult {
  contractAddress?: string;
  sourceCode: string;
  vulnerabilities: VulnerabilityFinding[];
  riskScore: number;
  summary: string;
}

export interface VulnerabilityFinding {
  pattern: VulnerabilityPattern;
  location: string;
  context: string;
  confidence: number;
  recommendation: string;
}

export class StaticAnalysisEngine {
  private vulnerabilityPatterns: VulnerabilityPattern[] = [
    {
      name: 'Reentrancy Vulnerability',
      description: 'External calls before state changes can lead to reentrancy attacks',
      severity: 'critical',
      pattern: /\.call\s*\([\s\S]*?\)[\s\S]*?(?=\w+\s*=|\w+\s*\+=|\w+\s*-=)/,
      category: 'reentrancy'
    },
    {
      name: 'Unchecked External Call',
      description: 'External calls without checking return value',
      severity: 'high',
      pattern: /\.call\s*\([^)]*\)\s*;/,
      category: 'logic'
    },
    {
      name: 'Integer Overflow/Underflow',
      description: 'Arithmetic operations without SafeMath in older Solidity versions',
      severity: 'high',
      pattern: /\b(?:uint|int)\d*\s+\w+\s*[+\-*/]\s*=|[+\-*/]\s*\w+(?!\s*;)/,
      category: 'arithmetic'
    },
    {
      name: 'Unprotected Function',
      description: 'Public/external functions without access control',
      severity: 'medium',
      pattern: /function\s+\w+\s*\([^)]*\)\s+(?:public|external)(?!\s+.*(?:onlyOwner|require|modifier))/,
      category: 'access_control'
    },
    {
      name: 'Block Timestamp Dependency',
      description: 'Using block.timestamp for critical logic',
      severity: 'medium',
      pattern: /block\.timestamp|now\b/,
      category: 'random'
    },
    {
      name: 'Tx Origin Usage',
      description: 'Using tx.origin instead of msg.sender',
      severity: 'high',
      pattern: /tx\.origin/,
      category: 'access_control'
    },
    {
      name: 'Delegatecall to Untrusted Contract',
      description: 'Delegatecall can be dangerous with untrusted contracts',
      severity: 'critical',
      pattern: /delegatecall\s*\(/,
      category: 'logic'
    },
    {
      name: 'Gas Limit DoS',
      description: 'Loops with unbounded iterations',
      severity: 'medium',
      pattern: /for\s*\([^;]*;\s*\w+\s*<\s*\w+\.length/,
      category: 'dos'
    },
    {
      name: 'Uninitialized Storage Pointer',
      description: 'Uninitialized storage pointers can be dangerous',
      severity: 'high',
      pattern: /\w+\s+storage\s+\w+(?!\s*=)/,
      category: 'logic'
    },
    {
      name: 'Weak Randomness',
      description: 'Using blockhash or block properties for randomness',
      severity: 'medium',
      pattern: /blockhash\s*\(|block\.(difficulty|gaslimit|number)/,
      category: 'random'
    },
    {
      name: 'Unchecked Low-Level Call',
      description: 'Using send() or transfer() without proper error handling',
      severity: 'medium',
      pattern: /\.(?:send|transfer)\s*\([^)]*\)(?!\s*;?\s*(?:require|assert))/,
      category: 'logic'
    },
    {
      name: 'Front-Running Vulnerability',
      description: 'Functions susceptible to front-running attacks',
      severity: 'medium',
      pattern: /function\s+\w*(?:buy|sell|trade|swap|bid|auction)\w*\s*\([^)]*\)\s+(?:public|external)/,
      category: 'logic'
    },
    {
      name: 'Price Oracle Manipulation',
      description: 'Potential price oracle manipulation vulnerability',
      severity: 'high',
      pattern: /\.getPrice\(\)|\.latestRoundData\(\)|price\s*=.*\.call/,
      category: 'logic'
    },
    {
      name: 'Flash Loan Attack Vector',
      description: 'Functions that could be vulnerable to flash loan attacks',
      severity: 'high',
      pattern: /function\s+\w*(?:liquidate|arbitrage|flashloan)\w*|balanceOf\(address\(this\)\)/,
      category: 'logic'
    },
    {
      name: 'Approval Race Condition',
      description: 'ERC20 approve race condition vulnerability',
      severity: 'medium',
      pattern: /function\s+approve\s*\([^)]*\).*\{[\s\S]*?allowance\[.*?\]\s*=.*?amount/,
      category: 'logic'
    },
    {
      name: 'Suicide/Selfdestruct Usage',
      description: 'Usage of selfdestruct can be dangerous',
      severity: 'high',
      pattern: /selfdestruct\s*\(|suicide\s*\(/,
      category: 'logic'
    }
  ];

  async analyzeSourceCode(sourceCode: string, contractAddress?: string): Promise<AnalysisResult> {
    const vulnerabilities: VulnerabilityFinding[] = [];

    for (const pattern of this.vulnerabilityPatterns) {
      const findings = this.findPatternMatches(sourceCode, pattern);
      vulnerabilities.push(...findings);
    }

    const riskScore = this.calculateRiskScore(vulnerabilities);
    const summary = this.generateSummary(vulnerabilities, riskScore);

    return {
      contractAddress,
      sourceCode,
      vulnerabilities,
      riskScore,
      summary
    };
  }

  private findPatternMatches(sourceCode: string, pattern: VulnerabilityPattern): VulnerabilityFinding[] {
    const findings: VulnerabilityFinding[] = [];
    const regex = typeof pattern.pattern === 'string' 
      ? new RegExp(pattern.pattern, 'g') 
      : new RegExp(pattern.pattern.source, 'g');

    let match;
    while ((match = regex.exec(sourceCode)) !== null) {
      const lineNumber = sourceCode.substring(0, match.index).split('\n').length;
      const contextStart = Math.max(0, match.index - 100);
      const contextEnd = Math.min(sourceCode.length, match.index + match[0].length + 100);
      const context = sourceCode.substring(contextStart, contextEnd);

      findings.push({
        pattern,
        location: `Line ${lineNumber}`,
        context: context.trim(),
        confidence: this.calculateConfidence(match[0], pattern),
        recommendation: this.getRecommendation(pattern)
      });
    }

    return findings;
  }

  private calculateConfidence(match: string, pattern: VulnerabilityPattern): number {
    // Simple confidence calculation based on pattern specificity
    const baseConfidence = 0.7;
    
    // Increase confidence for more specific patterns
    if (match.includes('require') || match.includes('modifier')) {
      return Math.max(0.3, baseConfidence - 0.3); // Lower confidence if protective measures exist
    }
    
    if (pattern.severity === 'critical') {
      return Math.min(0.95, baseConfidence + 0.2);
    }
    
    return baseConfidence;
  }

  private getRecommendation(pattern: VulnerabilityPattern): string {
    const recommendations: Record<string, string> = {
      'Reentrancy Vulnerability': 'Use the Checks-Effects-Interactions pattern or ReentrancyGuard modifier',
      'Unchecked External Call': 'Always check the return value of external calls',
      'Integer Overflow/Underflow': 'Use SafeMath library or Solidity 0.8+ with built-in overflow checks',
      'Unprotected Function': 'Add proper access control modifiers like onlyOwner',
      'Block Timestamp Dependency': 'Avoid using block.timestamp for critical logic, use oracles for time-sensitive operations',
      'Tx Origin Usage': 'Use msg.sender instead of tx.origin for authorization',
      'Delegatecall to Untrusted Contract': 'Only use delegatecall with trusted contracts and validate the target',
      'Gas Limit DoS': 'Implement pagination or limit array sizes to prevent gas limit issues',
      'Uninitialized Storage Pointer': 'Always initialize storage pointers explicitly',
      'Weak Randomness': 'Use secure randomness sources like Chainlink VRF',
      'Unchecked Low-Level Call': 'Use require() or assert() to check the return value of send/transfer calls',
      'Front-Running Vulnerability': 'Implement commit-reveal schemes or use time locks to prevent front-running',
      'Price Oracle Manipulation': 'Use multiple oracles, implement price deviation checks, and add time-weighted averages',
      'Flash Loan Attack Vector': 'Implement proper checks for flash loan protection and validate state changes',
      'Approval Race Condition': 'Implement increaseAllowance/decreaseAllowance pattern instead of direct approval',
      'Suicide/Selfdestruct Usage': 'Avoid using selfdestruct, consider safer alternatives for contract upgrades'
    };

    return recommendations[pattern.name] || 'Review this pattern for potential security issues';
  }

  private calculateRiskScore(vulnerabilities: VulnerabilityFinding[]): number {
    if (vulnerabilities.length === 0) return 0;

    const severityWeights = {
      low: 1,
      medium: 3,
      high: 7,
      critical: 10
    };

    const totalScore = vulnerabilities.reduce((score, vuln) => {
      const weight = severityWeights[vuln.pattern.severity];
      return score + (weight * vuln.confidence);
    }, 0);

    // Normalize to 0-100 scale
    const maxPossibleScore = vulnerabilities.length * 10;
    return Math.min(100, Math.round((totalScore / maxPossibleScore) * 100));
  }

  private generateSummary(vulnerabilities: VulnerabilityFinding[], riskScore: number): string {
    const severityCounts = vulnerabilities.reduce((counts, vuln) => {
      counts[vuln.pattern.severity] = (counts[vuln.pattern.severity] || 0) + 1;
      return counts;
    }, {} as Record<string, number>);

    const severityText = Object.entries(severityCounts)
      .map(([severity, count]) => `${count} ${severity}`)
      .join(', ');

    const riskLevel = riskScore >= 70 ? 'HIGH' : riskScore >= 40 ? 'MEDIUM' : 'LOW';

    return `Risk Score: ${riskScore}/100 (${riskLevel})\n` +
           `Found ${vulnerabilities.length} potential vulnerabilities: ${severityText}\n` +
           `Categories affected: ${[...new Set(vulnerabilities.map(v => v.pattern.category))].join(', ')}`;
  }

  addCustomPattern(pattern: VulnerabilityPattern): void {
    this.vulnerabilityPatterns.push(pattern);
  }

  getPatterns(): VulnerabilityPattern[] {
    return [...this.vulnerabilityPatterns];
  }
}