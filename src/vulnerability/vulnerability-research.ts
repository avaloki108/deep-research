import * as fs from 'fs/promises';

import { VulnerabilityResearchEngine, VulnerabilityTarget } from './research-engine';

export async function generateVulnerabilityReport(
  targets: VulnerabilityTarget[],
  summary: string,
  recommendations: string[],
  potentialFindings: string[],
  originalQuery: string
): Promise<string> {
  const highPriorityTargets = targets.filter(t => t.priority === 'high');
  const mediumPriorityTargets = targets.filter(t => t.priority === 'medium');
  const lowPriorityTargets = targets.filter(t => t.priority === 'low');

  let report = `# Vulnerability Research Report

## Query: ${originalQuery}

## Executive Summary

${summary}

## Risk Assessment

- **Total Targets**: ${targets.length}
- **High Priority**: ${highPriorityTargets.length}
- **Medium Priority**: ${mediumPriorityTargets.length}
- **Low Priority**: ${lowPriorityTargets.length}

## Recommendations

${recommendations.map(rec => `- ${rec}`).join('\n')}

## Potential Vulnerabilities to Investigate

${potentialFindings.map(finding => `- ${finding}`).join('\n')}

`;

  // Add detailed target analysis
  if (highPriorityTargets.length > 0) {
    report += `## High Priority Targets

`;
    for (const target of highPriorityTargets) {
      report += formatTargetSection(target);
    }
  }

  if (mediumPriorityTargets.length > 0) {
    report += `## Medium Priority Targets

`;
    for (const target of mediumPriorityTargets) {
      report += formatTargetSection(target);
    }
  }

  if (lowPriorityTargets.length > 0) {
    report += `## Low Priority Targets

`;
    for (const target of lowPriorityTargets) {
      report += formatTargetSection(target);
    }
  }

  // Add methodology section
  report += `## Research Methodology

This vulnerability research was conducted using the following approach:

1. **Bug Bounty Platform Analysis**: Scraped major platforms (ImmuneFi, Code4rena, HackerOne, Bugcrowd) for relevant programs
2. **GitHub Repository Discovery**: Searched for smart contract repositories matching the query criteria
3. **Static Code Analysis**: Analyzed smart contract source code for common vulnerability patterns
4. **Risk Prioritization**: Assessed targets based on bounty rewards, repository metrics, and vulnerability findings
5. **AI-Enhanced Insights**: Used AI to generate strategic recommendations and identify likely vulnerability types

## Vulnerability Patterns Analyzed

The static analysis engine checked for the following vulnerability types:

- **Reentrancy Attacks**: External calls before state changes
- **Access Control Issues**: Unprotected functions and authorization bypasses
- **Integer Overflow/Underflow**: Arithmetic vulnerabilities
- **Logic Errors**: Uninitialized storage, unchecked calls
- **Randomness Issues**: Weak entropy sources
- **DoS Vulnerabilities**: Gas limit issues and unbounded loops
- **Privacy Issues**: Information disclosure vulnerabilities

## Next Steps

1. **Manual Code Review**: Conduct detailed review of high-priority targets
2. **Dynamic Testing**: Set up test environments for identified protocols
3. **Exploit Development**: Create proof-of-concept exploits for discovered vulnerabilities
4. **Responsible Disclosure**: Follow proper disclosure procedures for any findings

---

*Report generated by Deep Research Vulnerability Engine*
`;

  return report;
}

function formatTargetSection(target: VulnerabilityTarget): string {
  let section = `### ${getTargetTitle(target)}

**Type**: ${target.type}  
**Priority**: ${target.priority.toUpperCase()}  
**Source**: ${target.source}  
**URL**: ${target.identifier}  

**Analysis**: ${target.reasoning}

`;

  if (target.bountyProgram) {
    section += `**Bounty Program**: ${target.bountyProgram.platform} - ${target.bountyProgram.name}  
**Reward Range**: ${target.bountyProgram.rewardRange}  
**Technologies**: ${target.bountyProgram.technology.join(', ')}  

`;
  }

  if (target.analysisResult) {
    section += `**Static Analysis Results**:
- Risk Score: ${target.analysisResult.riskScore}/100
- Vulnerabilities Found: ${target.analysisResult.vulnerabilities.length}
- Categories: ${[...new Set(target.analysisResult.vulnerabilities.map(v => v.pattern.category))].join(', ')}

`;

    if (target.analysisResult.vulnerabilities.length > 0) {
      section += `**Key Vulnerabilities**:
`;
      for (const vuln of target.analysisResult.vulnerabilities.slice(0, 3)) {
        section += `- **${vuln.pattern.name}** (${vuln.pattern.severity}): ${vuln.pattern.description}
  - Location: ${vuln.location}
  - Confidence: ${Math.round(vuln.confidence * 100)}%
  - Recommendation: ${vuln.recommendation}

`;
      }
    }
  }

  return section;
}

function getTargetTitle(target: VulnerabilityTarget): string {
  if (target.bountyProgram) {
    return target.bountyProgram.name;
  }

  if (target.type === 'repository') {
    const urlParts = target.identifier.split('/');
    if (urlParts.length >= 2) {
      return urlParts[urlParts.length - 1] || 'Unknown Repository'; // repo name
    }
  }

  return target.identifier;
}

export async function saveVulnerabilityReport(report: string, filename: string = 'vulnerability-report.md'): Promise<void> {
  try {
    await fs.writeFile(filename, report, 'utf-8');
    console.log(`\n‚úÖ Vulnerability report saved to ${filename}`);
  } catch (error) {
    console.error('Error saving vulnerability report:', error);
    throw error;
  }
}

export async function runVulnerabilityResearch(
  query: string,
  options: {
    maxTargets?: number;
    focusOnBounties?: boolean;
    includeContractAnalysis?: boolean;
    minStars?: number;
    githubToken?: string;
    ethersRpcUrl?: string;
  } = {}
): Promise<string> {
  console.log(`üîç Starting vulnerability research for: "${query}"`);
  
  const engine = new VulnerabilityResearchEngine({
    githubToken: options.githubToken || process.env.GITHUB_TOKEN,
    ethersRpcUrl: options.ethersRpcUrl
  });

  const results = await engine.conductVulnerabilityResearch(query, {
    maxTargets: options.maxTargets || 20,
    focusOnBounties: options.focusOnBounties !== false,
    includeContractAnalysis: options.includeContractAnalysis !== false,
    minStars: options.minStars || 50
  });

  const report = await generateVulnerabilityReport(
    results.targets,
    results.summary,
    results.recommendations,
    results.potentialFindings,
    query
  );

  await saveVulnerabilityReport(report);

  return report;
}